/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. All data is
 * isolated within a user-specific document tree, ensuring that a user can only ever
 * access their own information. Anonymous and password-based sign-in are supported,
 * but both require a valid authentication session to access any data.
 *
 * Data Structure: The data is organized hierarchically. A top-level 'users' collection
 * holds user profile documents. Each user profile document, identified by the user's
 * UID, contains a 'medicines' subcollection for that user's private inventory.
 * The path itself (/users/{userId}/...) is the primary mechanism for authorization.
 *
 * Key Security Decisions:
 * - User Enumeration is Disallowed: Listing the top-level '/users' collection is forbidden
 *   to prevent malicious actors from discovering all users of the application.
 * - Strict Ownership: All read and write operations are gated by a check that ensures the
 *   requesting user's UID matches the {userId} in the document path.
 * - Relational Integrity: On document creation, rules validate that the internal 'id' or
 *   'userId' field matches the {userId} from the path, ensuring data consistency. These
 *   linking fields are immutable and cannot be changed on update.
 *
 * Denormalization for Authorization: Authorization is based on the document path, which is
 * the most performant method. The {userId} wildcard is used directly in rules, avoiding
 * the need for any costly 'get()' or 'exists()' calls to other documents for authorization
 * checks. The 'userId' field on Medicine documents serves as a data integrity check rather
 * than an authorization control.
 *
 * Structural Segregation: User data is naturally segregated by the collection structure.
 * A user's private medicine list is in a subcollection (/users/{userId}/medicines)
 * which can be queried efficiently and securely without risk of exposing another user's data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    /**
     * isSignedIn
     * Checks if the user is authenticated. This is a prerequisite for all data access.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * isOwner
     * @param userId The user ID from the document path.
     * Validates that the requesting user is the owner of the document.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * isExistingOwner
     * @param userId The user ID from the document path.
     * A robust check for updates and deletes, ensuring the user is the owner
     * and the document actually exists before the operation.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * incomingUserProfileIsValid
     * @param userId The user ID from the document path.
     * Validates that a new UserProfile document contains an 'id' field that
     * matches the document's path ID, ensuring relational integrity.
     */
    function incomingUserProfileIsValid(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * updatedUserProfileIsValid
     * Validates that the 'id' field of a UserProfile is immutable.
     */
    function updatedUserProfileIsValid() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * incomingMedicineIsValid
     * @param userId The user ID from the document path.
     * Validates that a new Medicine document contains a 'userId' field that
     * correctly links it back to its parent user profile.
     */
    function incomingMedicineIsValid(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * updatedMedicineIsValid
     * Validates that the 'userId' field of a Medicine document is immutable.
     */
    function updatedMedicineIsValid() {
      return request.resource.data.userId == resource.data.userId;
    }

    /**
     * @description Rules for a user's own profile document.
     * @path /users/{userId}
     * @allow (get) An authenticated user with UID 'user123' to read their own profile at '/users/user123'.
     * @deny (get) An authenticated user with UID 'user456' from reading the profile at '/users/user123'.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && incomingUserProfileIsValid(userId);
      allow update: if isExistingOwner(userId) && updatedUserProfileIsValid();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for a user's private medicine inventory.
     * @path /users/{userId}/medicines/{medicineId}
     * @allow (list) An authenticated user 'user123' to list all documents in '/users/user123/medicines'.
     * @deny (list) An authenticated user 'user456' from listing documents in '/users/user123/medicines'.
     * @principle Enforces document ownership for writes and inherits access control from the parent path.
     */
    match /users/{userId}/medicines/{medicineId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && incomingMedicineIsValid(userId);
      allow update: if isExistingOwner(userId) && updatedMedicineIsValid();
      allow delete: if isExistingOwner(userId);
    }
  }
}